#include "../math.h"

matrixsquaremath::matrixsquaremath(int rowsandcolumns) : matrixmath(rowsandcolumns, rowsandcolumns) { }

char* matrixsquaremath::squareMultiply(char* out, char* matrix, char* matrix1) { int rowsandcolumns = this->rows; char* ret = (char*)calloc(rowsandcolumns * rowsandcolumns, sizeof(char)); for(int r = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++) for(int e = 0; e < rowsandcolumns; e++) ret[r * rowsandcolumns + c] += matrix[r * rowsandcolumns + e] * matrix1[e * rowsandcolumns + c]; for(int r = 0, i = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, i++) out[i] = ret[i]; delete ret; return out; }
short* matrixsquaremath::squareMultiply(short* out, char* matrix, char* matrix1) { int rowsandcolumns = this->rows; short* ret = (short*)calloc(rowsandcolumns * rowsandcolumns, sizeof(short)); for(int r = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++) for(int e = 0; e < rowsandcolumns; e++) ret[r * rowsandcolumns + c] += matrix[r * rowsandcolumns + e] * matrix1[e * rowsandcolumns + c]; for(int r = 0, i = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, i++) out[i] = ret[i]; delete ret; return out; }
short* matrixsquaremath::squareMultiply(short* out, short* matrix, short* matrix1) { int rowsandcolumns = this->rows; short* ret = (short*)calloc(rowsandcolumns * rowsandcolumns, sizeof(short)); for(int r = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++) for(int e = 0; e < rowsandcolumns; e++) ret[r * rowsandcolumns + c] += matrix[r * rowsandcolumns + e] * matrix1[e * rowsandcolumns + c]; for(int r = 0, i = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, i++) out[i] = ret[i]; delete ret; return out; }
int* matrixsquaremath::squareMultiply(int* out, short* matrix, short* matrix1) { int rowsandcolumns = this->rows; int* ret = (int*)calloc(rowsandcolumns * rowsandcolumns, sizeof(int)); for(int r = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++) for(int e = 0; e < rowsandcolumns; e++) ret[r * rowsandcolumns + c] += matrix[r * rowsandcolumns + e] * matrix1[e * rowsandcolumns + c]; for(int r = 0, i = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, i++) out[i] = ret[i]; delete ret; return out; }
int* matrixsquaremath::squareMultiply(int* out, int* matrix, int* matrix1) { int rowsandcolumns = this->rows; int* ret = (int*)calloc(rowsandcolumns * rowsandcolumns, sizeof(int)); for(int r = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++) for(int e = 0; e < rowsandcolumns; e++) ret[r * rowsandcolumns + c] += matrix[r * rowsandcolumns + e] * matrix1[e * rowsandcolumns + c]; for(int r = 0, i = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, i++) out[i] = ret[i]; delete ret; return out; }
long long* matrixsquaremath::squareMultiply(long long* out, int* matrix, int* matrix1) { int rowsandcolumns = this->rows; long long* ret = (long long*)calloc(rowsandcolumns * rowsandcolumns, sizeof(long long)); for(int r = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++) for(int e = 0; e < rowsandcolumns; e++) ret[r * rowsandcolumns + c] += matrix[r * rowsandcolumns + e] * matrix1[e * rowsandcolumns + c]; for(int r = 0, i = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, i++) out[i] = ret[i]; delete ret; return out; }
long long* matrixsquaremath::squareMultiply(long long* out, long long* matrix, long long* matrix1) { int rowsandcolumns = this->rows; long long* ret = (long long*)calloc(rowsandcolumns * rowsandcolumns, sizeof(long long)); for(int r = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++) for(int e = 0; e < rowsandcolumns; e++) ret[r * rowsandcolumns + c] += matrix[r * rowsandcolumns + e] * matrix1[e * rowsandcolumns + c]; for(int r = 0, i = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, i++) out[i] = ret[i]; delete ret; return out; }
__int128* matrixsquaremath::squareMultiply(__int128* out, long long* matrix, long long* matrix1) { int rowsandcolumns = this->rows; __int128* ret = (__int128*)calloc(rowsandcolumns * rowsandcolumns, sizeof(__int128)); for(int r = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++) for(int e = 0; e < rowsandcolumns; e++) ret[r * rowsandcolumns + c] += matrix[r * rowsandcolumns + e] * matrix1[e * rowsandcolumns + c]; for(int r = 0, i = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, i++) out[i] = ret[i]; delete ret; return out; }
__int128* matrixsquaremath::squareMultiply(__int128* out, __int128* matrix, __int128* matrix1) { int rowsandcolumns = this->rows; __int128* ret = (__int128*)calloc(rowsandcolumns * rowsandcolumns, sizeof(__int128)); for(int r = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++) for(int e = 0; e < rowsandcolumns; e++) ret[r * rowsandcolumns + c] += matrix[r * rowsandcolumns + e] * matrix1[e * rowsandcolumns + c]; for(int r = 0, i = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, i++) out[i] = ret[i]; delete ret; return out; }
float* matrixsquaremath::squareMultiply(float* out, float* matrix, float* matrix1) { int rowsandcolumns = this->rows; float* ret = (float*)calloc(rowsandcolumns * rowsandcolumns, sizeof(float)); for(int r = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++) for(int e = 0; e < rowsandcolumns; e++) ret[r * rowsandcolumns + c] += matrix[r * rowsandcolumns + e] * matrix1[e * rowsandcolumns + c]; for(int r = 0, i = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, i++) out[i] = ret[i]; delete ret; return out; }
double* matrixsquaremath::squareMultiply(double* out, float* matrix, float* matrix1) { int rowsandcolumns = this->rows; double* ret = (double*)calloc(rowsandcolumns * rowsandcolumns, sizeof(double)); for(int r = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++) for(int e = 0; e < rowsandcolumns; e++) ret[r * rowsandcolumns + c] += matrix[r * rowsandcolumns + e] * matrix1[e * rowsandcolumns + c]; for(int r = 0, i = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, i++) out[i] = ret[i]; delete ret; return out; }
double* matrixsquaremath::squareMultiply(double* out, double* matrix, double* matrix1) { int rowsandcolumns = this->rows; double* ret = (double*)calloc(rowsandcolumns * rowsandcolumns, sizeof(double)); for(int r = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++) for(int e = 0; e < rowsandcolumns; e++) ret[r * rowsandcolumns + c] += matrix[r * rowsandcolumns + e] * matrix1[e * rowsandcolumns + c]; for(int r = 0, i = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, i++) out[i] = ret[i]; delete ret; return out; }
__float128* matrixsquaremath::squareMultiply(__float128* out, double* matrix, double* matrix1) { int rowsandcolumns = this->rows; __float128* ret = (__float128*)calloc(rowsandcolumns * rowsandcolumns, sizeof(__float128)); for(int r = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++) for(int e = 0; e < rowsandcolumns; e++) ret[r * rowsandcolumns + c] += matrix[r * rowsandcolumns + e] * matrix1[e * rowsandcolumns + c]; for(int r = 0, i = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, i++) out[i] = ret[i]; delete ret; return out; }
__float128* matrixsquaremath::squareMultiply(__float128* out, __float128* matrix, __float128* matrix1) { int rowsandcolumns = this->rows; __float128* ret = (__float128*)calloc(rowsandcolumns * rowsandcolumns, sizeof(__float128)); for(int r = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++) for(int e = 0; e < rowsandcolumns; e++) ret[r * rowsandcolumns + c] += matrix[r * rowsandcolumns + e] * matrix1[e * rowsandcolumns + c]; for(int r = 0, i = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, i++) out[i] = ret[i]; delete ret; return out; }

char* matrixsquaremath::identity(char* out) { int rowsandcolumns = this->rows; for(int i = 0, c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++, i++) out[i] = c == r ? 1 : 0; return out; }
short* matrixsquaremath::identity(short* out) { int rowsandcolumns = this->rows; for(int i = 0, c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++, i++) out[i] = c == r ? 1 : 0; return out; }
int* matrixsquaremath::identity(int* out) { int rowsandcolumns = this->rows; for(int i = 0, c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++, i++) out[i] = c == r ? 1 : 0; return out; }
long long* matrixsquaremath::identity(long long* out) { int rowsandcolumns = this->rows; for(int i = 0, c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++, i++) out[i] = c == r ? 1 : 0; return out; }
__int128* matrixsquaremath::identity(__int128* out) { int rowsandcolumns = this->rows; for(int i = 0, c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++, i++) out[i] = c == r ? 1 : 0; return out; }
float* matrixsquaremath::identity(float* out) { int rowsandcolumns = this->rows; for(int i = 0, c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++, i++) out[i] = c == r ? 1 : 0; return out; }
double* matrixsquaremath::identity(double* out) { int rowsandcolumns = this->rows; for(int i = 0, c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++, i++) out[i] = c == r ? 1 : 0; return out; }
__float128* matrixsquaremath::identity(__float128* out) { int rowsandcolumns = this->rows; for(int i = 0, c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++, i++) out[i] = c == r ? 1 : 0; return out; }

void matrixsquaremath::identityI8(bool condensed, int count, ...) { int rowsandcolumns = this->rows; va_list matrices; va_start(matrices, condensed ? 1 : count); char** ms = condensed ? va_arg(matrices, char**) : NULL; for(int m = 0; m < count; m++) { char* matrix = condensed ? ms[m] : va_arg(matrices, char*); for(int r = 0, j = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, j++) matrix[j] = c == r ? 1 : 0; } }
void matrixsquaremath::identityI16(bool condensed, int count, ...) { int rowsandcolumns = this->rows; va_list matrices; va_start(matrices, condensed ? 1 : count); short** ms = condensed ? va_arg(matrices, short**) : NULL; for(int m = 0; m < count; m++) { short* matrix = condensed ? ms[m] : va_arg(matrices, short*); for(int r = 0, j = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, j++) matrix[j] = c == r ? 1 : 0; } }
void matrixsquaremath::identityI32(bool condensed, int count, ...) { int rowsandcolumns = this->rows; va_list matrices; va_start(matrices, condensed ? 1 : count); int** ms = condensed ? va_arg(matrices, int**) : NULL; for(int m = 0; m < count; m++) { int* matrix = condensed ? ms[m] : va_arg(matrices, int*); for(int r = 0, j = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, j++) matrix[j] = c == r ? 1 : 0; } }
void matrixsquaremath::identityI64(bool condensed, int count, ...) { int rowsandcolumns = this->rows; va_list matrices; va_start(matrices, condensed ? 1 : count); long long** ms = condensed ? va_arg(matrices, long long**) : NULL; for(int m = 0; m < count; m++) { long long* matrix = condensed ? ms[m] : va_arg(matrices, long long*); for(int r = 0, j = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, j++) matrix[j] = c == r ? 1 : 0; } }
void matrixsquaremath::identityI128(bool condensed, int count, ...) { int rowsandcolumns = this->rows; va_list matrices; va_start(matrices, condensed ? 1 : count); __int128** ms = condensed ? va_arg(matrices, __int128**) : NULL; for(int m = 0; m < count; m++) { __int128* matrix = condensed ? ms[m] : va_arg(matrices, __int128*); for(int r = 0, j = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, j++) matrix[j] = c == r ? 1 : 0; } }
void matrixsquaremath::identityF32(bool condensed, int count, ...) { int rowsandcolumns = this->rows; va_list matrices; va_start(matrices, condensed ? 1 : count); float** ms = condensed ? va_arg(matrices, float**) : NULL; for(int m = 0; m < count; m++) { float* matrix = condensed ? ms[m] : va_arg(matrices, float*); for(int r = 0, j = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, j++) matrix[j] = c == r ? 1 : 0; } }
void matrixsquaremath::identityF64(bool condensed, int count, ...) { int rowsandcolumns = this->rows; va_list matrices; va_start(matrices, condensed ? 1 : count); double** ms = condensed ? va_arg(matrices, double**) : NULL; for(int m = 0; m < count; m++) { double* matrix = condensed ? ms[m] : va_arg(matrices, double*); for(int r = 0, j = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, j++) matrix[j] = c == r ? 1 : 0; } }
void matrixsquaremath::identityF128(bool condensed, int count, ...) { int rowsandcolumns = this->rows; va_list matrices; va_start(matrices, condensed ? 1 : count); __float128** ms = condensed ? va_arg(matrices, __float128**) : NULL; for(int m = 0; m < count; m++) { __float128* matrix = condensed ? ms[m] : va_arg(matrices, __float128*); for(int r = 0, j = 0; r < rowsandcolumns; r++) for(int c = 0; c < rowsandcolumns; c++, j++) matrix[j] = c == r ? 1 : 0; } }

char matrixsquaremath::determinantI8(char* matrix) { int rowsandcolumns = this->rows; if(rowsandcolumns == 2) return matrix[0] * matrix[3] - matrix[1] * matrix[2]; int usedcolumns[rowsandcolumns]; bool positives[rowsandcolumns - 2]; char dets[rowsandcolumns - 1]; for(int i = 0; i < rowsandcolumns; i++) { if(i < rowsandcolumns - 1) { dets[i] = 0; if(i < rowsandcolumns - 2) positives[i] = true; } usedcolumns[i] = -1; } int row = 0; while(true) { if(row == rowsandcolumns - 2) { int i = 0, firstColumn = -1, secondColumn = -1; while(true) { int* r = firstColumn < 0 ? &firstColumn : secondColumn < 0 ? &secondColumn : NULL; if(r == NULL) break; bool free = true; for(int j = 0; free && j < rowsandcolumns; j++) free = usedcolumns[j] != i; if(free) *r = i; i++; } dets[row] += matrix[row * rowsandcolumns + firstColumn] * matrix[(row + 1) * rowsandcolumns + secondColumn] - matrix[(row + 1) * rowsandcolumns + firstColumn] * matrix[row * rowsandcolumns + secondColumn]; row--; continue; } int* column = &usedcolumns[row]; if(row > 0) { bool* positive = &positives[row]; if(*column != -1) { dets[row] += (*positive ? 1 : -1) * matrix[row * rowsandcolumns + *column] * dets[row + 1]; dets[row + 1] = 0; *positive = !(*positive); } int nextColumn = -1; for(int i = *column + 1; i < rowsandcolumns; i++) { bool free = true; for(int j = 0; free && j < row; j++) free = usedcolumns[j] != i; if(free) { nextColumn = i; break; } } *column = nextColumn; if(nextColumn == -1) { *positive = true; row--; } else row++; } else { if(*column != -1) { bool* positive = &positives[0]; dets[0] += (*positive ? 1 : -1) * matrix[*column] * dets[1]; dets[1] = 0; *positive = !(*positive); } if(*column == rowsandcolumns - 1) break; else { (*column)++; row++; } } } return dets[0]; }
short matrixsquaremath::determinantI16(char* matrix) { int rowsandcolumns = this->rows; if(rowsandcolumns == 2) return matrix[0] * matrix[3] - matrix[1] * matrix[2]; int usedcolumns[rowsandcolumns]; bool positives[rowsandcolumns - 2]; short dets[rowsandcolumns - 1]; for(int i = 0; i < rowsandcolumns; i++) { if(i < rowsandcolumns - 1) { dets[i] = 0; if(i < rowsandcolumns - 2) positives[i] = true; } usedcolumns[i] = -1; } int row = 0; while(true) { if(row == rowsandcolumns - 2) { int i = 0, firstColumn = -1, secondColumn = -1; while(true) { int* r = firstColumn < 0 ? &firstColumn : secondColumn < 0 ? &secondColumn : NULL; if(r == NULL) break; bool free = true; for(int j = 0; free && j < rowsandcolumns; j++) free = usedcolumns[j] != i; if(free) *r = i; i++; } dets[row] += matrix[row * rowsandcolumns + firstColumn] * matrix[(row + 1) * rowsandcolumns + secondColumn] - matrix[(row + 1) * rowsandcolumns + firstColumn] * matrix[row * rowsandcolumns + secondColumn]; row--; continue; } int* column = &usedcolumns[row]; if(row > 0) { bool* positive = &positives[row]; if(*column != -1) { dets[row] += (*positive ? 1 : -1) * matrix[row * rowsandcolumns + *column] * dets[row + 1]; dets[row + 1] = 0; *positive = !(*positive); } int nextColumn = -1; for(int i = *column + 1; i < rowsandcolumns; i++) { bool free = true; for(int j = 0; free && j < row; j++) free = usedcolumns[j] != i; if(free) { nextColumn = i; break; } } *column = nextColumn; if(nextColumn == -1) { *positive = true; row--; } else row++; } else { if(*column != -1) { bool* positive = &positives[0]; dets[0] += (*positive ? 1 : -1) * matrix[*column] * dets[1]; dets[1] = 0; *positive = !(*positive); } if(*column == rowsandcolumns - 1) break; else { (*column)++; row++; } } } return dets[0]; }
short matrixsquaremath::determinantI16(short* matrix) { int rowsandcolumns = this->rows; if(rowsandcolumns == 2) return matrix[0] * matrix[3] - matrix[1] * matrix[2]; int usedcolumns[rowsandcolumns]; bool positives[rowsandcolumns - 2]; short dets[rowsandcolumns - 1]; for(int i = 0; i < rowsandcolumns; i++) { if(i < rowsandcolumns - 1) { dets[i] = 0; if(i < rowsandcolumns - 2) positives[i] = true; } usedcolumns[i] = -1; } int row = 0; while(true) { if(row == rowsandcolumns - 2) { int i = 0, firstColumn = -1, secondColumn = -1; while(true) { int* r = firstColumn < 0 ? &firstColumn : secondColumn < 0 ? &secondColumn : NULL; if(r == NULL) break; bool free = true; for(int j = 0; free && j < rowsandcolumns; j++) free = usedcolumns[j] != i; if(free) *r = i; i++; } dets[row] += matrix[row * rowsandcolumns + firstColumn] * matrix[(row + 1) * rowsandcolumns + secondColumn] - matrix[(row + 1) * rowsandcolumns + firstColumn] * matrix[row * rowsandcolumns + secondColumn]; row--; continue; } int* column = &usedcolumns[row]; if(row > 0) { bool* positive = &positives[row]; if(*column != -1) { dets[row] += (*positive ? 1 : -1) * matrix[row * rowsandcolumns + *column] * dets[row + 1]; dets[row + 1] = 0; *positive = !(*positive); } int nextColumn = -1; for(int i = *column + 1; i < rowsandcolumns; i++) { bool free = true; for(int j = 0; free && j < row; j++) free = usedcolumns[j] != i; if(free) { nextColumn = i; break; } } *column = nextColumn; if(nextColumn == -1) { *positive = true; row--; } else row++; } else { if(*column != -1) { bool* positive = &positives[0]; dets[0] += (*positive ? 1 : -1) * matrix[*column] * dets[1]; dets[1] = 0; *positive = !(*positive); } if(*column == rowsandcolumns - 1) break; else { (*column)++; row++; } } } return dets[0]; }
int matrixsquaremath::determinantI32(short* matrix) { int rowsandcolumns = this->rows; if(rowsandcolumns == 2) return matrix[0] * matrix[3] - matrix[1] * matrix[2]; int usedcolumns[rowsandcolumns]; bool positives[rowsandcolumns - 2]; int dets[rowsandcolumns - 1]; for(int i = 0; i < rowsandcolumns; i++) { if(i < rowsandcolumns - 1) { dets[i] = 0; if(i < rowsandcolumns - 2) positives[i] = true; } usedcolumns[i] = -1; } int row = 0; while(true) { if(row == rowsandcolumns - 2) { int i = 0, firstColumn = -1, secondColumn = -1; while(true) { int* r = firstColumn < 0 ? &firstColumn : secondColumn < 0 ? &secondColumn : NULL; if(r == NULL) break; bool free = true; for(int j = 0; free && j < rowsandcolumns; j++) free = usedcolumns[j] != i; if(free) *r = i; i++; } dets[row] += matrix[row * rowsandcolumns + firstColumn] * matrix[(row + 1) * rowsandcolumns + secondColumn] - matrix[(row + 1) * rowsandcolumns + firstColumn] * matrix[row * rowsandcolumns + secondColumn]; row--; continue; } int* column = &usedcolumns[row]; if(row > 0) { bool* positive = &positives[row]; if(*column != -1) { dets[row] += (*positive ? 1 : -1) * matrix[row * rowsandcolumns + *column] * dets[row + 1]; dets[row + 1] = 0; *positive = !(*positive); } int nextColumn = -1; for(int i = *column + 1; i < rowsandcolumns; i++) { bool free = true; for(int j = 0; free && j < row; j++) free = usedcolumns[j] != i; if(free) { nextColumn = i; break; } } *column = nextColumn; if(nextColumn == -1) { *positive = true; row--; } else row++; } else { if(*column != -1) { bool* positive = &positives[0]; dets[0] += (*positive ? 1 : -1) * matrix[*column] * dets[1]; dets[1] = 0; *positive = !(*positive); } if(*column == rowsandcolumns - 1) break; else { (*column)++; row++; } } } return dets[0]; }
int matrixsquaremath::determinantI32(int* matrix) { int rowsandcolumns = this->rows; if(rowsandcolumns == 2) return matrix[0] * matrix[3] - matrix[1] * matrix[2]; int usedcolumns[rowsandcolumns]; bool positives[rowsandcolumns - 2]; int dets[rowsandcolumns - 1]; for(int i = 0; i < rowsandcolumns; i++) { if(i < rowsandcolumns - 1) { dets[i] = 0; if(i < rowsandcolumns - 2) positives[i] = true; } usedcolumns[i] = -1; } int row = 0; while(true) { if(row == rowsandcolumns - 2) { int i = 0, firstColumn = -1, secondColumn = -1; while(true) { int* r = firstColumn < 0 ? &firstColumn : secondColumn < 0 ? &secondColumn : NULL; if(r == NULL) break; bool free = true; for(int j = 0; free && j < rowsandcolumns; j++) free = usedcolumns[j] != i; if(free) *r = i; i++; } dets[row] += matrix[row * rowsandcolumns + firstColumn] * matrix[(row + 1) * rowsandcolumns + secondColumn] - matrix[(row + 1) * rowsandcolumns + firstColumn] * matrix[row * rowsandcolumns + secondColumn]; row--; continue; } int* column = &usedcolumns[row]; if(row > 0) { bool* positive = &positives[row]; if(*column != -1) { dets[row] += (*positive ? 1 : -1) * matrix[row * rowsandcolumns + *column] * dets[row + 1]; dets[row + 1] = 0; *positive = !(*positive); } int nextColumn = -1; for(int i = *column + 1; i < rowsandcolumns; i++) { bool free = true; for(int j = 0; free && j < row; j++) free = usedcolumns[j] != i; if(free) { nextColumn = i; break; } } *column = nextColumn; if(nextColumn == -1) { *positive = true; row--; } else row++; } else { if(*column != -1) { bool* positive = &positives[0]; dets[0] += (*positive ? 1 : -1) * matrix[*column] * dets[1]; dets[1] = 0; *positive = !(*positive); } if(*column == rowsandcolumns - 1) break; else { (*column)++; row++; } } } return dets[0]; }
long long matrixsquaremath::determinantI64(int* matrix) { int rowsandcolumns = this->rows; if(rowsandcolumns == 2) return matrix[0] * matrix[3] - matrix[1] * matrix[2]; int usedcolumns[rowsandcolumns]; bool positives[rowsandcolumns - 2]; long long dets[rowsandcolumns - 1]; for(int i = 0; i < rowsandcolumns; i++) { if(i < rowsandcolumns - 1) { dets[i] = 0; if(i < rowsandcolumns - 2) positives[i] = true; } usedcolumns[i] = -1; } int row = 0; while(true) { if(row == rowsandcolumns - 2) { int i = 0, firstColumn = -1, secondColumn = -1; while(true) { int* r = firstColumn < 0 ? &firstColumn : secondColumn < 0 ? &secondColumn : NULL; if(r == NULL) break; bool free = true; for(int j = 0; free && j < rowsandcolumns; j++) free = usedcolumns[j] != i; if(free) *r = i; i++; } dets[row] += matrix[row * rowsandcolumns + firstColumn] * matrix[(row + 1) * rowsandcolumns + secondColumn] - matrix[(row + 1) * rowsandcolumns + firstColumn] * matrix[row * rowsandcolumns + secondColumn]; row--; continue; } int* column = &usedcolumns[row]; if(row > 0) { bool* positive = &positives[row]; if(*column != -1) { dets[row] += (*positive ? 1 : -1) * matrix[row * rowsandcolumns + *column] * dets[row + 1]; dets[row + 1] = 0; *positive = !(*positive); } int nextColumn = -1; for(int i = *column + 1; i < rowsandcolumns; i++) { bool free = true; for(int j = 0; free && j < row; j++) free = usedcolumns[j] != i; if(free) { nextColumn = i; break; } } *column = nextColumn; if(nextColumn == -1) { *positive = true; row--; } else row++; } else { if(*column != -1) { bool* positive = &positives[0]; dets[0] += (*positive ? 1 : -1) * matrix[*column] * dets[1]; dets[1] = 0; *positive = !(*positive); } if(*column == rowsandcolumns - 1) break; else { (*column)++; row++; } } } return dets[0]; }
long long matrixsquaremath::determinantI64(long long* matrix) { int rowsandcolumns = this->rows; if(rowsandcolumns == 2) return matrix[0] * matrix[3] - matrix[1] * matrix[2]; int usedcolumns[rowsandcolumns]; bool positives[rowsandcolumns - 2]; long long dets[rowsandcolumns - 1]; for(int i = 0; i < rowsandcolumns; i++) { if(i < rowsandcolumns - 1) { dets[i] = 0; if(i < rowsandcolumns - 2) positives[i] = true; } usedcolumns[i] = -1; } int row = 0; while(true) { if(row == rowsandcolumns - 2) { int i = 0, firstColumn = -1, secondColumn = -1; while(true) { int* r = firstColumn < 0 ? &firstColumn : secondColumn < 0 ? &secondColumn : NULL; if(r == NULL) break; bool free = true; for(int j = 0; free && j < rowsandcolumns; j++) free = usedcolumns[j] != i; if(free) *r = i; i++; } dets[row] += matrix[row * rowsandcolumns + firstColumn] * matrix[(row + 1) * rowsandcolumns + secondColumn] - matrix[(row + 1) * rowsandcolumns + firstColumn] * matrix[row * rowsandcolumns + secondColumn]; row--; continue; } int* column = &usedcolumns[row]; if(row > 0) { bool* positive = &positives[row]; if(*column != -1) { dets[row] += (*positive ? 1 : -1) * matrix[row * rowsandcolumns + *column] * dets[row + 1]; dets[row + 1] = 0; *positive = !(*positive); } int nextColumn = -1; for(int i = *column + 1; i < rowsandcolumns; i++) { bool free = true; for(int j = 0; free && j < row; j++) free = usedcolumns[j] != i; if(free) { nextColumn = i; break; } } *column = nextColumn; if(nextColumn == -1) { *positive = true; row--; } else row++; } else { if(*column != -1) { bool* positive = &positives[0]; dets[0] += (*positive ? 1 : -1) * matrix[*column] * dets[1]; dets[1] = 0; *positive = !(*positive); } if(*column == rowsandcolumns - 1) break; else { (*column)++; row++; } } } return dets[0]; }
__int128 matrixsquaremath::determinantI128(long long* matrix) { int rowsandcolumns = this->rows; if(rowsandcolumns == 2) return matrix[0] * matrix[3] - matrix[1] * matrix[2]; int usedcolumns[rowsandcolumns]; bool positives[rowsandcolumns - 2]; __int128 dets[rowsandcolumns - 1]; for(int i = 0; i < rowsandcolumns; i++) { if(i < rowsandcolumns - 1) { dets[i] = 0; if(i < rowsandcolumns - 2) positives[i] = true; } usedcolumns[i] = -1; } int row = 0; while(true) { if(row == rowsandcolumns - 2) { int i = 0, firstColumn = -1, secondColumn = -1; while(true) { int* r = firstColumn < 0 ? &firstColumn : secondColumn < 0 ? &secondColumn : NULL; if(r == NULL) break; bool free = true; for(int j = 0; free && j < rowsandcolumns; j++) free = usedcolumns[j] != i; if(free) *r = i; i++; } dets[row] += matrix[row * rowsandcolumns + firstColumn] * matrix[(row + 1) * rowsandcolumns + secondColumn] - matrix[(row + 1) * rowsandcolumns + firstColumn] * matrix[row * rowsandcolumns + secondColumn]; row--; continue; } int* column = &usedcolumns[row]; if(row > 0) { bool* positive = &positives[row]; if(*column != -1) { dets[row] += (*positive ? 1 : -1) * matrix[row * rowsandcolumns + *column] * dets[row + 1]; dets[row + 1] = 0; *positive = !(*positive); } int nextColumn = -1; for(int i = *column + 1; i < rowsandcolumns; i++) { bool free = true; for(int j = 0; free && j < row; j++) free = usedcolumns[j] != i; if(free) { nextColumn = i; break; } } *column = nextColumn; if(nextColumn == -1) { *positive = true; row--; } else row++; } else { if(*column != -1) { bool* positive = &positives[0]; dets[0] += (*positive ? 1 : -1) * matrix[*column] * dets[1]; dets[1] = 0; *positive = !(*positive); } if(*column == rowsandcolumns - 1) break; else { (*column)++; row++; } } } return dets[0]; }
__int128 matrixsquaremath::determinantI128(__int128* matrix) { int rowsandcolumns = this->rows; if(rowsandcolumns == 2) return matrix[0] * matrix[3] - matrix[1] * matrix[2]; int usedcolumns[rowsandcolumns]; bool positives[rowsandcolumns - 2]; __int128 dets[rowsandcolumns - 1]; for(int i = 0; i < rowsandcolumns; i++) { if(i < rowsandcolumns - 1) { dets[i] = 0; if(i < rowsandcolumns - 2) positives[i] = true; } usedcolumns[i] = -1; } int row = 0; while(true) { if(row == rowsandcolumns - 2) { int i = 0, firstColumn = -1, secondColumn = -1; while(true) { int* r = firstColumn < 0 ? &firstColumn : secondColumn < 0 ? &secondColumn : NULL; if(r == NULL) break; bool free = true; for(int j = 0; free && j < rowsandcolumns; j++) free = usedcolumns[j] != i; if(free) *r = i; i++; } dets[row] += matrix[row * rowsandcolumns + firstColumn] * matrix[(row + 1) * rowsandcolumns + secondColumn] - matrix[(row + 1) * rowsandcolumns + firstColumn] * matrix[row * rowsandcolumns + secondColumn]; row--; continue; } int* column = &usedcolumns[row]; if(row > 0) { bool* positive = &positives[row]; if(*column != -1) { dets[row] += (*positive ? 1 : -1) * matrix[row * rowsandcolumns + *column] * dets[row + 1]; dets[row + 1] = 0; *positive = !(*positive); } int nextColumn = -1; for(int i = *column + 1; i < rowsandcolumns; i++) { bool free = true; for(int j = 0; free && j < row; j++) free = usedcolumns[j] != i; if(free) { nextColumn = i; break; } } *column = nextColumn; if(nextColumn == -1) { *positive = true; row--; } else row++; } else { if(*column != -1) { bool* positive = &positives[0]; dets[0] += (*positive ? 1 : -1) * matrix[*column] * dets[1]; dets[1] = 0; *positive = !(*positive); } if(*column == rowsandcolumns - 1) break; else { (*column)++; row++; } } } return dets[0]; }
float matrixsquaremath::determinantF32(float* matrix) { int rowsandcolumns = this->rows; if(rowsandcolumns == 2) return matrix[0] * matrix[3] - matrix[1] * matrix[2]; int usedcolumns[rowsandcolumns]; bool positives[rowsandcolumns - 2]; float dets[rowsandcolumns - 1]; for(int i = 0; i < rowsandcolumns; i++) { if(i < rowsandcolumns - 1) { dets[i] = 0; if(i < rowsandcolumns - 2) positives[i] = true; } usedcolumns[i] = -1; } int row = 0; while(true) { if(row == rowsandcolumns - 2) { int i = 0, firstColumn = -1, secondColumn = -1; while(true) { int* r = firstColumn < 0 ? &firstColumn : secondColumn < 0 ? &secondColumn : NULL; if(r == NULL) break; bool free = true; for(int j = 0; free && j < rowsandcolumns; j++) free = usedcolumns[j] != i; if(free) *r = i; i++; } dets[row] += matrix[row * rowsandcolumns + firstColumn] * matrix[(row + 1) * rowsandcolumns + secondColumn] - matrix[(row + 1) * rowsandcolumns + firstColumn] * matrix[row * rowsandcolumns + secondColumn]; row--; continue; } int* column = &usedcolumns[row]; if(row > 0) { bool* positive = &positives[row]; if(*column != -1) { dets[row] += (*positive ? 1 : -1) * matrix[row * rowsandcolumns + *column] * dets[row + 1]; dets[row + 1] = 0; *positive = !(*positive); } int nextColumn = -1; for(int i = *column + 1; i < rowsandcolumns; i++) { bool free = true; for(int j = 0; free && j < row; j++) free = usedcolumns[j] != i; if(free) { nextColumn = i; break; } } *column = nextColumn; if(nextColumn == -1) { *positive = true; row--; } else row++; } else { if(*column != -1) { bool* positive = &positives[0]; dets[0] += (*positive ? 1 : -1) * matrix[*column] * dets[1]; dets[1] = 0; *positive = !(*positive); } if(*column == rowsandcolumns - 1) break; else { (*column)++; row++; } } } return dets[0]; }
double matrixsquaremath::determinantF64(float* matrix) { int rowsandcolumns = this->rows; if(rowsandcolumns == 2) return matrix[0] * matrix[3] - matrix[1] * matrix[2]; int usedcolumns[rowsandcolumns]; bool positives[rowsandcolumns - 2]; double dets[rowsandcolumns - 1]; for(int i = 0; i < rowsandcolumns; i++) { if(i < rowsandcolumns - 1) { dets[i] = 0; if(i < rowsandcolumns - 2) positives[i] = true; } usedcolumns[i] = -1; } int row = 0; while(true) { if(row == rowsandcolumns - 2) { int i = 0, firstColumn = -1, secondColumn = -1; while(true) { int* r = firstColumn < 0 ? &firstColumn : secondColumn < 0 ? &secondColumn : NULL; if(r == NULL) break; bool free = true; for(int j = 0; free && j < rowsandcolumns; j++) free = usedcolumns[j] != i; if(free) *r = i; i++; } dets[row] += matrix[row * rowsandcolumns + firstColumn] * matrix[(row + 1) * rowsandcolumns + secondColumn] - matrix[(row + 1) * rowsandcolumns + firstColumn] * matrix[row * rowsandcolumns + secondColumn]; row--; continue; } int* column = &usedcolumns[row]; if(row > 0) { bool* positive = &positives[row]; if(*column != -1) { dets[row] += (*positive ? 1 : -1) * matrix[row * rowsandcolumns + *column] * dets[row + 1]; dets[row + 1] = 0; *positive = !(*positive); } int nextColumn = -1; for(int i = *column + 1; i < rowsandcolumns; i++) { bool free = true; for(int j = 0; free && j < row; j++) free = usedcolumns[j] != i; if(free) { nextColumn = i; break; } } *column = nextColumn; if(nextColumn == -1) { *positive = true; row--; } else row++; } else { if(*column != -1) { bool* positive = &positives[0]; dets[0] += (*positive ? 1 : -1) * matrix[*column] * dets[1]; dets[1] = 0; *positive = !(*positive); } if(*column == rowsandcolumns - 1) break; else { (*column)++; row++; } } } return dets[0]; }
double matrixsquaremath::determinantF64(double* matrix) { int rowsandcolumns = this->rows; if(rowsandcolumns == 2) return matrix[0] * matrix[3] - matrix[1] * matrix[2]; int usedcolumns[rowsandcolumns]; bool positives[rowsandcolumns - 2]; double dets[rowsandcolumns - 1]; for(int i = 0; i < rowsandcolumns; i++) { if(i < rowsandcolumns - 1) { dets[i] = 0; if(i < rowsandcolumns - 2) positives[i] = true; } usedcolumns[i] = -1; } int row = 0; while(true) { if(row == rowsandcolumns - 2) { int i = 0, firstColumn = -1, secondColumn = -1; while(true) { int* r = firstColumn < 0 ? &firstColumn : secondColumn < 0 ? &secondColumn : NULL; if(r == NULL) break; bool free = true; for(int j = 0; free && j < rowsandcolumns; j++) free = usedcolumns[j] != i; if(free) *r = i; i++; } dets[row] += matrix[row * rowsandcolumns + firstColumn] * matrix[(row + 1) * rowsandcolumns + secondColumn] - matrix[(row + 1) * rowsandcolumns + firstColumn] * matrix[row * rowsandcolumns + secondColumn]; row--; continue; } int* column = &usedcolumns[row]; if(row > 0) { bool* positive = &positives[row]; if(*column != -1) { dets[row] += (*positive ? 1 : -1) * matrix[row * rowsandcolumns + *column] * dets[row + 1]; dets[row + 1] = 0; *positive = !(*positive); } int nextColumn = -1; for(int i = *column + 1; i < rowsandcolumns; i++) { bool free = true; for(int j = 0; free && j < row; j++) free = usedcolumns[j] != i; if(free) { nextColumn = i; break; } } *column = nextColumn; if(nextColumn == -1) { *positive = true; row--; } else row++; } else { if(*column != -1) { bool* positive = &positives[0]; dets[0] += (*positive ? 1 : -1) * matrix[*column] * dets[1]; dets[1] = 0; *positive = !(*positive); } if(*column == rowsandcolumns - 1) break; else { (*column)++; row++; } } } return dets[0]; }
__float128 matrixsquaremath::determinantF128(double* matrix) { int rowsandcolumns = this->rows; if(rowsandcolumns == 2) return matrix[0] * matrix[3] - matrix[1] * matrix[2]; int usedcolumns[rowsandcolumns]; bool positives[rowsandcolumns - 2]; __float128 dets[rowsandcolumns - 1]; for(int i = 0; i < rowsandcolumns; i++) { if(i < rowsandcolumns - 1) { dets[i] = 0; if(i < rowsandcolumns - 2) positives[i] = true; } usedcolumns[i] = -1; } int row = 0; while(true) { if(row == rowsandcolumns - 2) { int i = 0, firstColumn = -1, secondColumn = -1; while(true) { int* r = firstColumn < 0 ? &firstColumn : secondColumn < 0 ? &secondColumn : NULL; if(r == NULL) break; bool free = true; for(int j = 0; free && j < rowsandcolumns; j++) free = usedcolumns[j] != i; if(free) *r = i; i++; } dets[row] += matrix[row * rowsandcolumns + firstColumn] * matrix[(row + 1) * rowsandcolumns + secondColumn] - matrix[(row + 1) * rowsandcolumns + firstColumn] * matrix[row * rowsandcolumns + secondColumn]; row--; continue; } int* column = &usedcolumns[row]; if(row > 0) { bool* positive = &positives[row]; if(*column != -1) { dets[row] += (*positive ? 1 : -1) * matrix[row * rowsandcolumns + *column] * dets[row + 1]; dets[row + 1] = 0; *positive = !(*positive); } int nextColumn = -1; for(int i = *column + 1; i < rowsandcolumns; i++) { bool free = true; for(int j = 0; free && j < row; j++) free = usedcolumns[j] != i; if(free) { nextColumn = i; break; } } *column = nextColumn; if(nextColumn == -1) { *positive = true; row--; } else row++; } else { if(*column != -1) { bool* positive = &positives[0]; dets[0] += (*positive ? 1 : -1) * matrix[*column] * dets[1]; dets[1] = 0; *positive = !(*positive); } if(*column == rowsandcolumns - 1) break; else { (*column)++; row++; } } } return dets[0]; }
__float128 matrixsquaremath::determinantF128(__float128* matrix) { int rowsandcolumns = this->rows; if(rowsandcolumns == 2) return matrix[0] * matrix[3] - matrix[1] * matrix[2]; int usedcolumns[rowsandcolumns]; bool positives[rowsandcolumns - 2]; __float128 dets[rowsandcolumns - 1]; for(int i = 0; i < rowsandcolumns; i++) { if(i < rowsandcolumns - 1) { dets[i] = 0; if(i < rowsandcolumns - 2) positives[i] = true; } usedcolumns[i] = -1; } int row = 0; while(true) { if(row == rowsandcolumns - 2) { int i = 0, firstColumn = -1, secondColumn = -1; while(true) { int* r = firstColumn < 0 ? &firstColumn : secondColumn < 0 ? &secondColumn : NULL; if(r == NULL) break; bool free = true; for(int j = 0; free && j < rowsandcolumns; j++) free = usedcolumns[j] != i; if(free) *r = i; i++; } dets[row] += matrix[row * rowsandcolumns + firstColumn] * matrix[(row + 1) * rowsandcolumns + secondColumn] - matrix[(row + 1) * rowsandcolumns + firstColumn] * matrix[row * rowsandcolumns + secondColumn]; row--; continue; } int* column = &usedcolumns[row]; if(row > 0) { bool* positive = &positives[row]; if(*column != -1) { dets[row] += (*positive ? 1 : -1) * matrix[row * rowsandcolumns + *column] * dets[row + 1]; dets[row + 1] = 0; *positive = !(*positive); } int nextColumn = -1; for(int i = *column + 1; i < rowsandcolumns; i++) { bool free = true; for(int j = 0; free && j < row; j++) free = usedcolumns[j] != i; if(free) { nextColumn = i; break; } } *column = nextColumn; if(nextColumn == -1) { *positive = true; row--; } else row++; } else { if(*column != -1) { bool* positive = &positives[0]; dets[0] += (*positive ? 1 : -1) * matrix[*column] * dets[1]; dets[1] = 0; *positive = !(*positive); } if(*column == rowsandcolumns - 1) break; else { (*column)++; row++; } } } return dets[0]; }

float* matrixsquaremath::inverse(float* out, char* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } float* ss[rowsandcolumns * rowsandcolumns]; char* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { float* s = ss[index] = (float*)calloc(rowsandcolumns + 1, sizeof(float)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { float* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { float* s = ss[r * rowsandcolumns + c]; float e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(float* s : ss) delete s; return out; }
float* matrixsquaremath::inverse(float* out, short* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } float* ss[rowsandcolumns * rowsandcolumns]; short* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { float* s = ss[index] = (float*)calloc(rowsandcolumns + 1, sizeof(float)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { float* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { float* s = ss[r * rowsandcolumns + c]; float e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(float* s : ss) delete s; return out; }
float* matrixsquaremath::inverse(float* out, int* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } float* ss[rowsandcolumns * rowsandcolumns]; int* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { float* s = ss[index] = (float*)calloc(rowsandcolumns + 1, sizeof(float)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { float* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { float* s = ss[r * rowsandcolumns + c]; float e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(float* s : ss) delete s; return out; }
float* matrixsquaremath::inverse(float* out, long long* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } float* ss[rowsandcolumns * rowsandcolumns]; long long* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { float* s = ss[index] = (float*)calloc(rowsandcolumns + 1, sizeof(float)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { float* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { float* s = ss[r * rowsandcolumns + c]; float e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(float* s : ss) delete s; return out; }
float* matrixsquaremath::inverse(float* out, __int128* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } float* ss[rowsandcolumns * rowsandcolumns]; __int128* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { float* s = ss[index] = (float*)calloc(rowsandcolumns + 1, sizeof(float)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { float* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { float* s = ss[r * rowsandcolumns + c]; float e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(float* s : ss) delete s; return out; }
float* matrixsquaremath::inverse(float* out, float* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } float* ss[rowsandcolumns * rowsandcolumns]; float* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { float* s = ss[index] = (float*)calloc(rowsandcolumns + 1, sizeof(float)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { float* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { float* s = ss[r * rowsandcolumns + c]; float e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(float* s : ss) delete s; return out; }
double* matrixsquaremath::inverse(double* out, char* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } double* ss[rowsandcolumns * rowsandcolumns]; char* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { double* s = ss[index] = (double*)calloc(rowsandcolumns + 1, sizeof(double)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { double* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { double* s = ss[r * rowsandcolumns + c]; double e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(double* s : ss) delete s; return out; }
double* matrixsquaremath::inverse(double* out, short* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } double* ss[rowsandcolumns * rowsandcolumns]; short* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { double* s = ss[index] = (double*)calloc(rowsandcolumns + 1, sizeof(double)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { double* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { double* s = ss[r * rowsandcolumns + c]; double e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(double* s : ss) delete s; return out; }
double* matrixsquaremath::inverse(double* out, int* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } double* ss[rowsandcolumns * rowsandcolumns]; int* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { double* s = ss[index] = (double*)calloc(rowsandcolumns + 1, sizeof(double)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { double* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { double* s = ss[r * rowsandcolumns + c]; double e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(double* s : ss) delete s; return out; }
double* matrixsquaremath::inverse(double* out, long long* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } double* ss[rowsandcolumns * rowsandcolumns]; long long* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { double* s = ss[index] = (double*)calloc(rowsandcolumns + 1, sizeof(double)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { double* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { double* s = ss[r * rowsandcolumns + c]; double e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(double* s : ss) delete s; return out; }
double* matrixsquaremath::inverse(double* out, __int128* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } double* ss[rowsandcolumns * rowsandcolumns]; __int128* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { double* s = ss[index] = (double*)calloc(rowsandcolumns + 1, sizeof(double)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { double* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { double* s = ss[r * rowsandcolumns + c]; double e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(double* s : ss) delete s; return out; }
double* matrixsquaremath::inverse(double* out, float* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } double* ss[rowsandcolumns * rowsandcolumns]; float* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { double* s = ss[index] = (double*)calloc(rowsandcolumns + 1, sizeof(double)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { double* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { double* s = ss[r * rowsandcolumns + c]; double e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(double* s : ss) delete s; return out; }
double* matrixsquaremath::inverse(double* out, double* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } double* ss[rowsandcolumns * rowsandcolumns]; double* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { double* s = ss[index] = (double*)calloc(rowsandcolumns + 1, sizeof(double)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { double* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { double* s = ss[r * rowsandcolumns + c]; double e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(double* s : ss) delete s; return out; }
__float128* matrixsquaremath::inverse(__float128* out, char* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } __float128* ss[rowsandcolumns * rowsandcolumns]; char* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { __float128* s = ss[index] = (__float128*)calloc(rowsandcolumns + 1, sizeof(__float128)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { __float128* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { __float128* s = ss[r * rowsandcolumns + c]; __float128 e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(__float128* s : ss) delete s; return out; }
__float128* matrixsquaremath::inverse(__float128* out, short* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } __float128* ss[rowsandcolumns * rowsandcolumns]; short* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { __float128* s = ss[index] = (__float128*)calloc(rowsandcolumns + 1, sizeof(__float128)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { __float128* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { __float128* s = ss[r * rowsandcolumns + c]; __float128 e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(__float128* s : ss) delete s; return out; }
__float128* matrixsquaremath::inverse(__float128* out, int* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } __float128* ss[rowsandcolumns * rowsandcolumns]; int* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { __float128* s = ss[index] = (__float128*)calloc(rowsandcolumns + 1, sizeof(__float128)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { __float128* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { __float128* s = ss[r * rowsandcolumns + c]; __float128 e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(__float128* s : ss) delete s; return out; }
__float128* matrixsquaremath::inverse(__float128* out, long long* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } __float128* ss[rowsandcolumns * rowsandcolumns]; long long* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { __float128* s = ss[index] = (__float128*)calloc(rowsandcolumns + 1, sizeof(__float128)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { __float128* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { __float128* s = ss[r * rowsandcolumns + c]; __float128 e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(__float128* s : ss) delete s; return out; }
__float128* matrixsquaremath::inverse(__float128* out, __int128* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } __float128* ss[rowsandcolumns * rowsandcolumns]; __int128* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { __float128* s = ss[index] = (__float128*)calloc(rowsandcolumns + 1, sizeof(__float128)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { __float128* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { __float128* s = ss[r * rowsandcolumns + c]; __float128 e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(__float128* s : ss) delete s; return out; }
__float128* matrixsquaremath::inverse(__float128* out, float* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } __float128* ss[rowsandcolumns * rowsandcolumns]; float* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { __float128* s = ss[index] = (__float128*)calloc(rowsandcolumns + 1, sizeof(__float128)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { __float128* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { __float128* s = ss[r * rowsandcolumns + c]; __float128 e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(__float128* s : ss) delete s; return out; }
__float128* matrixsquaremath::inverse(__float128* out, double* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } __float128* ss[rowsandcolumns * rowsandcolumns]; double* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { __float128* s = ss[index] = (__float128*)calloc(rowsandcolumns + 1, sizeof(__float128)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { __float128* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { __float128* s = ss[r * rowsandcolumns + c]; __float128 e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(__float128* s : ss) delete s; return out; }
__float128* matrixsquaremath::inverse(__float128* out, __float128* matrix) { int rowsandcolumns = this->rows; int rs[rowsandcolumns]; for(int i = 0; i < rowsandcolumns; i++) rs[i] = -1; int a = 0; while(true) { if(a == -1) return NULL; int r = ++rs[a]; if(r == rowsandcolumns) rs[a--] = -1; else { bool c = matrix[r * rowsandcolumns + a] == 0; for(int i = 0; !c && i < a; i++) c = rs[i] == r; if(!c) { if(a == rowsandcolumns - 1) break; else a++; } } } __float128* ss[rowsandcolumns * rowsandcolumns]; __float128* ref = matrix + rs[0] * rowsandcolumns; for(int r = 0, index = 0; r < rowsandcolumns; r++, ref = matrix + rs[r] * rowsandcolumns) for(int c = 0; c < rowsandcolumns; c++, index++) { __float128* s = ss[index] = (__float128*)calloc(rowsandcolumns + 1, sizeof(__float128)); for(int e = 0; e < rowsandcolumns; e++) s[e] = ref[e]; if(r == c) s[rowsandcolumns] = -1; } for(int c = 0; c < rowsandcolumns; c++) for(int r = 0; r < rowsandcolumns; r++) { __float128* s = ss[r * rowsandcolumns + c]; for(int i = 0; i < r; i++) for(int j = i + 1; j <= rowsandcolumns; j++) s[j] -= s[i] * ss[i * rowsandcolumns + c][j]; for(int i = r + 1; i <= rowsandcolumns; i++) s[i] /= s[r]; } for(int c = 0; c < rowsandcolumns; c++) for(int r = rowsandcolumns - 1; r >= 0; r--) { __float128* s = ss[r * rowsandcolumns + c]; __float128 e = 0; for(int i = r + 1; i <= rowsandcolumns; i++) e -= s[i]; for(int i = 0; i < r; i++) ss[i * rowsandcolumns + c][r] *= e; out[r * rowsandcolumns + rs[c]] = e; } for(__float128* s : ss) delete s; return out; }

char* matrixsquaremath::translate(char* out, char* matrix, char* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { char e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
short* matrixsquaremath::translate(short* out, char* matrix, char* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { short e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
short* matrixsquaremath::translate(short* out, short* matrix, short* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { short e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
int* matrixsquaremath::translate(int* out, short* matrix, short* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { int e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
int* matrixsquaremath::translate(int* out, int* matrix, int* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { int e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
long long* matrixsquaremath::translate(long long* out, int* matrix, int* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { long long e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
long long* matrixsquaremath::translate(long long* out, long long* matrix, long long* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { long long e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
__int128* matrixsquaremath::translate(__int128* out, long long* matrix, long long* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { __int128 e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
__int128* matrixsquaremath::translate(__int128* out, __int128* matrix, __int128* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { __int128 e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
float* matrixsquaremath::translate(float* out, char* matrix, float* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { float e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
float* matrixsquaremath::translate(float* out, short* matrix, float* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { float e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
float* matrixsquaremath::translate(float* out, int* matrix, float* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { float e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
float* matrixsquaremath::translate(float* out, long long* matrix, float* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { float e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
float* matrixsquaremath::translate(float* out, __int128* matrix, float* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { float e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
float* matrixsquaremath::translate(float* out, float* matrix, float* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { float e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
double* matrixsquaremath::translate(double* out, float* matrix, float* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { double e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
double* matrixsquaremath::translate(double* out, char* matrix, double* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { double e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
double* matrixsquaremath::translate(double* out, short* matrix, double* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { double e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
double* matrixsquaremath::translate(double* out, int* matrix, double* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { double e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
double* matrixsquaremath::translate(double* out, long long* matrix, double* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { double e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
double* matrixsquaremath::translate(double* out, __int128* matrix, double* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { double e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
double* matrixsquaremath::translate(double* out, float* matrix, double* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { double e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
double* matrixsquaremath::translate(double* out, double* matrix, double* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { double e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
__float128* matrixsquaremath::translate(__float128* out, double* matrix, double* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { __float128 e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
__float128* matrixsquaremath::translate(__float128* out, char* matrix, __float128* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { __float128 e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
__float128* matrixsquaremath::translate(__float128* out, short* matrix, __float128* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { __float128 e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
__float128* matrixsquaremath::translate(__float128* out, int* matrix, __float128* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { __float128 e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
__float128* matrixsquaremath::translate(__float128* out, long long* matrix, __float128* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { __float128 e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
__float128* matrixsquaremath::translate(__float128* out, __int128* matrix, __float128* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { __float128 e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
__float128* matrixsquaremath::translate(__float128* out, float* matrix, __float128* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { __float128 e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
__float128* matrixsquaremath::translate(__float128* out, double* matrix, __float128* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { __float128 e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
__float128* matrixsquaremath::translate(__float128* out, __float128* matrix, __float128* vector) { int rowsandcolumns = this->rows; for(int c = 0, b = rowsandcolumns * (rowsandcolumns - 1); c < rowsandcolumns; c++, b++) { __float128 e = matrix[b]; for(int r = 0, i = c; r < rowsandcolumns - 1; r++, i += rowsandcolumns) { e += (out[i] = matrix[i]) * vector[r]; } out[b] = e; } return out; }
